[
  {
    "id": 1,
    "title": "FizzBuzz",
    "description": "Write a function `fizzBuzz` that takes an integer `n` and returns an array of strings representing the numbers from 1 to `n`. But for multiples of three, add \"Fizz\" instead of the number, and for the multiples of five, add \"Buzz\". For numbers which are multiples of both three and five, add \"FizzBuzz\".",
    "initialCode": "function fizzBuzz(n: number): string[] {\n    // Your code here\n    return [];\n}",
    "tests": [
      {
        "code": "console.log(fizzBuzz(5));",
        "result": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"]"
      },
      {
        "code": "console.log(fizzBuzz(15));",
        "result": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]"
      },
      {
        "code": "console.log(fizzBuzz(1));",
        "result": "[\"1\"]"
      },
      {
        "code": "console.log(fizzBuzz(3));",
        "result": "[\"1\", \"2\", \"Fizz\"]"
      },
      {
        "code": "console.log(fizzBuzz(10));",
        "result": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\"]"
      }
    ]
  },
  {
    "id": 2,
    "title": "Anagram Checker",
    "description": "Write a function `isAnagram` that takes two strings `s` and `t` and returns `true` if `t` is an anagram of `s`, and `false` otherwise. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "initialCode": "function isAnagram(s: string, t: string): boolean {\n    // Your code here\n    return false;\n}",
    "tests": [
      {
        "code": "console.log(isAnagram(\"anagram\", \"nagaram\"));",
        "result": true
      },
      { "code": "console.log(isAnagram(\"rat\", \"car\"));", "result": false },
      {
        "code": "console.log(isAnagram(\"listen\", \"silent\"));",
        "result": true
      },
      {
        "code": "console.log(isAnagram(\"hello\", \"bello\"));",
        "result": false
      },
      { "code": "console.log(isAnagram(\"a\", \"a\"));", "result": true }
    ]
  },
  {
    "id": 3,
    "title": "Find the Missing Number",
    "description": "You are given an array containing `n` distinct numbers taken from the range `0` to `n`. Write a function `findMissingNumber` that finds the one number that is missing from the array.",
    "initialCode": "function findMissingNumber(nums: number[]): number {\n    // Your code here\n    return -1;\n}",
    "tests": [
      { "code": "console.log(findMissingNumber([3, 0, 1]));", "result": 2 },
      { "code": "console.log(findMissingNumber([0, 1]));", "result": 2 },
      {
        "code": "console.log(findMissingNumber([9,6,4,2,3,5,7,0,1]));",
        "result": 8
      },
      { "code": "console.log(findMissingNumber([0]));", "result": 1 },
      {
        "code": "console.log(findMissingNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15]));",
        "result": 11
      }
    ]
  },
  {
    "id": 4,
    "title": "Implementing a LRU Cache",
    "description": "\nDesign and implement a data structure for a Least Recently Used (LRU) cache. It should support the following operations:\n- get(key): Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\n- put(key, value): Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item.\n\nThe cache should be initialized with a positive capacity.\n\nFollow these guidelines:\n- Both operations (get and put) must be done in O(1) time complexity.\n- You can assume that all operations are valid (e.g., the number of calls to get and put is always positive).\n\n**Example:** \n\n```typescript \nLRUCache cache = new LRUCache(2); // capacity 2\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // returns 1\ncache.put(3, 3);    // evicts key 2\ncache.get(2);       // returns -1 (not found)\ncache.put(4, 4);    // evicts key 1\ncache.get(1);       // returns -1 (not found)\ncache.get(3);       // returns 3\ncache.get(4);       // returns 4\n```",
    "initialCode": "class LRUCache {\n  private capacity: number;\n  private map: Map<number, number>;\n\n  constructor(capacity: number) {\n    this.capacity = capacity;\n    this.map = new Map();\n  }\n\n  get(key: number): number {\n    if (!this.map.has(key)) {\n      return -1;\n    }\n    const value = this.map.get(key)!;\n    this.map.delete(key);\n    this.map.set(key, value);\n    return value;\n  }\n\n  put(key: number, value: number): void {\n    if (this.map.has(key)) {\n      this.map.delete(key);\n    } else if (this.map.size === this.capacity) {\n      const firstKey = this.map.keys().next().value;\n      this.map.delete(firstKey);\n    }\n    this.map.set(key, value);\n  }\n}\n",
    "tests": [
      {
        "code": "const cache = new LRUCache(2);\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);",
        "result": 1
      },
      {
        "code": "const cache = new LRUCache(2);\ncache.put(1, 1);\ncache.put(2, 2);\ncache.put(3, 3);\ncache.get(2);",
        "result": -1
      },
      {
        "code": "const cache = new LRUCache(2);\ncache.put(1, 1);\ncache.put(2, 2);\ncache.put(3, 3);\ncache.get(3);",
        "result": 3
      },
      {
        "code": "const cache = new LRUCache(2);\ncache.put(1, 1);\ncache.put(2, 2);\ncache.put(3, 3);\ncache.get(2);\ncache.put(4, 4);\ncache.get(1);",
        "result": -1
      },
      {
        "code": "const cache = new LRUCache(2);\ncache.put(1, 1);\ncache.put(2, 2);\ncache.put(3, 3);\ncache.get(2);\ncache.put(4, 4);\ncache.get(3);",
        "result": 3
      }
    ]
  }
]
